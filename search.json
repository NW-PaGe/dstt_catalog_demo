[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "\n\nNORTHWEST PATHOGEN GENOMICS CENTER OF EXCELLENCE\n\nData Catalog\n",
    "section": "",
    "text": "This is a static website and demo of a data catalog. Search for data objects in the metadata viewer, or visualize data product relationships in the directed acyclic graph (DAG) below.\n\ndag metdata viewer\n\n\ndocument.getElementById(\"dag_button\").addEventListener(\"click\", function() {\n  // Access the iframe containing the ShinyLive app\n  var iframe = document.querySelector(\"iframe\"); \n  if (iframe) {\n    // Use iframe's contentWindow to access the Shiny app's DOM\n    var iframeDocument = iframe.contentWindow.document;\n    // Use scrollIntoView on the desired section inside the iframe\n    var section = iframeDocument.getElementById(\"dag-br\");\n    if (section) {\n      section.scrollIntoView({behavior: \"smooth\"});\n    }\n  }\n});\n\n\n\n\n\n\n\ndocument.getElementById(\"mv_button\").addEventListener(\"click\", function() {\n  // Access the iframe containing the ShinyLive app\n  var iframe = document.querySelector(\"iframe\"); \n  if (iframe) {\n    // Use iframe's contentWindow to access the Shiny app's DOM\n    var iframeDocument = iframe.contentWindow.document;\n    // Use scrollIntoView on the desired section inside the iframe\n    var section = iframeDocument.getElementById(\"metadata-viewer-br\");\n    if (section) {\n      section.scrollIntoView({behavior: \"smooth\"});\n    }\n  }\n});\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#| standalone: true\n#| #components: [editor, viewer]\n#| viewerHeight: 1000\n#| column: page\n\n\n## file: app.R\n# import dag\nlibrary(shiny)\nlibrary(DiagrammeR)\nlibrary(dplyr)\nlibrary(tidyr)\n\n# Read the CSV file when the script starts\nmetadata &lt;- read.csv(url(\"https://raw.githubusercontent.com/NW-PaGe/dstt_catalog_demo/refs/heads/main/metadata.csv\")) %&gt;%\n  mutate(across(where(is.character), function(.) ifelse(. == '', NA_character_, .)))\n\n# Define UI for the app\ndag_ui &lt;- fluidPage(\n  sidebarLayout(\n    sidebarPanel(\n      h4(\"Select nodes\"),\n      checkboxGroupInput(\"selected_nodes\", \"Nodes\", choices = unique(metadata$Product_Name), selected = unique(metadata$Product_Name)),\n      hr()\n    ),\n    \n    mainPanel(\n      grVizOutput(\"dag_plot\", width = \"100%\", height = \"600px\")\n    )\n  )\n)\n\n# Define server logic for the app\ndag_server &lt;- function(input, output, session) {\n  \n  # Create a reactive DAG from selected nodes\n  reactive_dag &lt;- reactive({\n    ### Create nodes based on inclusion in selected input\n    nodes_final &lt;- metadata %&gt;% \n      filter(Product_Name %in% input$selected_nodes) %&gt;%\n      select(Product_Name) %&gt;% \n      mutate(Product_Name_Copy = Product_Name) %&gt;% \n      distinct()\n    \n    ### Create edges based on `Parent` and `Child` columns ----------------\n    \n    # unnest any nodes with 2+ parents or children\n    unnested_data &lt;- metadata %&gt;% \n      select(Product_Name, Parent, Child) %&gt;% \n      mutate(Product_Name_Copy = Product_Name) %&gt;% \n      tidyr::separate_rows(Parent, sep = \";\") %&gt;% \n      tidyr::separate_rows(Child, sep = \";\") %&gt;% \n      distinct()\n    \n    # identify all possible parents\n    parent_df &lt;- unnested_data %&gt;% \n      filter(!is.na(Parent)) %&gt;% \n      mutate(Child = Product_Name)\n\n    # identify all possible children\n    child_df &lt;- unnested_data %&gt;% \n      filter(!is.na(Child)) %&gt;% \n      mutate(Parent = Product_Name)\n    \n    # join parents and children to get all possible edges\n    edges &lt;- rbind(parent_df, child_df) %&gt;% \n      select(Parent, Child) %&gt;% \n      distinct()\n    \n    # get direct edges (edges where no product has been deselected)\n    direct_edges &lt;- edges %&gt;% \n      filter(Parent %in% input$selected_nodes & Child %in% input$selected_nodes) %&gt;% \n      mutate(style = 'solid') # set edge attribute so line will be solid\n    \n    # get indirect edges (edges where child or parent has been deselected)\n    indirect_parent &lt;- edges %&gt;% \n      filter(!Parent %in% input$selected_nodes) %&gt;% \n      rename(removed=Parent)\n    indirect_child &lt;- edges %&gt;% \n      filter(!Child %in% input$selected_nodes) %&gt;% \n      rename(removed=Child)\n    indirect_edges &lt;- indirect_parent %&gt;% \n      left_join(indirect_child, by='removed') %&gt;% \n      select(-removed) %&gt;% \n      mutate(style = 'dashed') # set edge attribute so line will be dashed\n    \n    # concat dfs for final edges df with direct/indirect relationships included\n    edges_final &lt;- rbind(indirect_edges, direct_edges)\n    \n    ### Create the DAG using DiagrammeR ------------------------------------------\n    dag &lt;- create_graph() %&gt;%\n      add_nodes_from_table(table = nodes_final,\n                           label_col = \"Product_Name\") %&gt;%\n      add_edges_from_table(table = edges_final,\n                           from_col = \"Parent\",\n                           to_col = \"Child\",\n                           from_to_map = \"Product_Name_Copy\")\n\n    return(dag)\n  })\n  \n  observe({\n    # Render the DAG plot\n    output$dag_plot &lt;- renderGrViz({\n      dag &lt;- reactive_dag()\n      dag %&gt;% render_graph()\n    })  \n  })\n  \n}\n\n# # render shinyapp\n# shinyApp(ui=dag_ui, server=dag_server)\n\n# import docx_to_html function\ndocx_to_html &lt;- function(doc) {\n  #' Convert docx to html \n  #' \n  #' Return a semi formatted html version of a docx file. This function\n  #' accepts docx objects (output by officer::read_docx) and outputs an html-marked character element\n  #' with some headers and tables formatted. Media will not be included in output.\n  #' \n  #' @param doc docx object output from officer::read_docx\n  #' @seealso [officer::read_docx()]\n  #' \n  \n  \n  library(officer)\n  library(dplyr)\n  library(htmltools)\n  \n  doc_content &lt;- officer::docx_summary(doc) # convert doc to data frame with rows of docx elements\n  \n  doc_content &lt;- dplyr::arrange(doc_content, doc_index, row_id, cell_id) # arrange df by index, then row id, then cell id\n  \n  html_content &lt;- \"\" # Initialize html content element\n  \n  is_table &lt;- FALSE # Set flag to check if a table is being constructed\n  \n  # Step through the document content rowwise to render paragraphs, headers, tables, and page breaks\n  for (i in 1:nrow(doc_content)) {\n    # close the row and table if the previous row was part of a table\n    if (is_table & !doc_content$content_type[i] %in% \"table cell\") {\n      html_content &lt;- paste0(html_content, \"&lt;/tr&gt;&lt;/table&gt;\")  # Close row and table\n      is_table &lt;- FALSE # reset to false\n    }\n    # if row is paragraph type ...\n    if (doc_content$content_type[i] %in% \"paragraph\") {\n      # insert a horizontal line if a page break is present\n      if (tolower(doc_content$text[i]) %in% 'page break') {\n        html_content &lt;- paste0(html_content, htmltools::hr())\n      # otherwise, if a heading style, insert text with a heading tag (add +1 to heading # as we assign title as h1 later)  \n      } else if (grepl(\"heading [1-5]\", doc_content$style_name[i])) {\n        header = gsub(\"heading ([1-5])\", \"\\\\1\", doc_content$style_name[i])\n        html_content &lt;- paste0(\n          html_content,\n          switch(as.numeric(header)+1,\n                 htmltools::h1(doc_content$text[i]),\n                 htmltools::h2(doc_content$text[i]),\n                 htmltools::h3(doc_content$text[i]),\n                 htmltools::h4(doc_content$text[i]),\n                 htmltools::h5(doc_content$text[i]),\n                 htmltools::h6(doc_content$text[i])\n          )\n        )\n      # otherwise, if a title style, insert text with h1 tags\n      } else if (tolower(doc_content$style_name[i]) %in% \"title\") {\n        html_content &lt;- paste0(html_content, htmltools::h1(doc_content$text[i]))\n      # otherwise, insert text with paragraph tags\n      } else {\n        html_content &lt;- paste0(html_content, htmltools::p(doc_content$text[i]))\n      }\n    # otherwise (if not a paragraph type), if it is a table cell in row 1 cell 1 (meaning, the first cell of a table), insert the table border\n    } else if (doc_content$content_type[i] %in% \"table cell\" & doc_content$row_id[i]%in%1 & doc_content$cell_id[i]%in%1) {\n      html_content &lt;- paste0(html_content, \"&lt;table border='1'&gt;\")  # Start a table\n      is_table &lt;- TRUE # set table flag to true\n    # otherwise, if table cell and the first cell of a new row, add a new row tag\n    } else if (doc_content$content_type[i] %in% \"table cell\" & doc_content$row_id[i] &gt; doc_content$row_id[i-1]) {\n      html_content &lt;- paste0(html_content, \"&lt;/tr&gt;&lt;tr&gt;\")  # Close prev row and start a new row\n    # insert text if not paragraph of table cell w/o formatting\n    } else if (!doc_content$content_type[i] %in% c(\"paragraph\", \"table cell\")) {\n      html_content &lt;- paste0(html_content, doc_content$text[i])\n    }\n    # if a table cell, insert text with td tag\n    if (doc_content$content_type[i] %in% \"table cell\") {\n      html_content &lt;- paste0(html_content, \"&lt;td&gt;\", doc_content$text[i], \"&lt;/td&gt;\")  # Add cell content\n    }\n  }        \n  \n  # convert character element to element marked as HTML\n  HTML(html_content)\n}\n\n# import split_values.R\nlibrary(stringr)\n\nsplit_values &lt;- function(x, sep=';', unlist=FALSE) {\n  #' split_values\n  #' \n  #' Function splits char elements inside char vectors and removes surrounding whitespace\n  #' \n  #' @param x character or vector of characters\n  #' @param sep string to split on; default \";\"\n  #' @param unlist whether or not to unlist the character list; default FALSE\n  #' @return a list (or vector, if unlist=TRUE) of character elements\n  #' \n  #' @example split_values(x=c('this', 'string; is', 'split')) \n  #' @example split_values(x=c('This will be return as a vector'), sep=',', unlist=TRUE)\n  #' \n  x = stringr::str_split(x, sep) # split by sep and return string\n  x = sapply(x, trimws) # trim whitespace of strings in list\n  if (unlist) {\n    x = unlist(x)\n  }\n  return(x)\n}\n\n # import server & ui code\nlibrary(shiny)\nlibrary(DT)\nlibrary(officer)\nlibrary(duckdb)\nlibrary(jsonlite)\n\n# Read the CSV file when the script starts\nmetadata &lt;- read.csv(url(\"https://raw.githubusercontent.com/NW-PaGe/dstt_catalog_demo/refs/heads/main/metadata.csv\")) %&gt;%\n  mutate(across(where(is.character), function(.) ifelse(. == '', NA_character_, .)))\n\n# Define the UI\nmetadata_ui &lt;- fluidPage(\n  # Add custom CSS\n  tags$head(\n    tags$style(HTML(\"\n      .filter-tag {\n        display: inline-block;\n        margin: 3px;\n        padding: 6px 12px;\n        background-color: #3498db;\n        color: white;\n        border-radius: 15px;\n        cursor: pointer;\n        font-size: 14px;\n        transition: background-color 0.3s ease;\n      }\n      .filter-tag:hover {\n        background-color: #2980b9;\n      }\n      .filter-label {\n        font-weight: bold;\n        margin-right: 5px;\n      }\n      .filter-value {\n        font-weight: normal;\n      }\n      .remove-icon {\n        margin-left: 8px;\n        font-weight: bold;\n        opacity: 0.8;\n      }\n      .filter-tag:hover .remove-icon {\n        opacity: 1;\n      }\n      #fileListContent {\n        max-height: none;\n        overflow-y: hidden;\n      }\n      #fileListContent li:nth-child(n+7) {\n        display: none;\n      }\n      #fileListContent li:nth-child(6) {\n        white-space: nowrap;\n        overflow: visible;\n        text-overflow: ellipsis;\n        opacity: 0.7;\n        position: relative;\n        padding-right: 20px;\n        list-style-type: disc !important;\n      }\n      #fileListContent li:nth-child(6) a {\n        overflow: hidden;\n        text-overflow: ellipsis;\n        white-space: nowrap;\n        display: block;\n      }\n      #fileListContent li:nth-child(6)::after {\n        content: '';\n        position: absolute;\n        bottom: 0;\n        left: -20px;\n        right: 0;\n        height: 60%;\n        background: linear-gradient(to bottom, transparent, white);\n        pointer-events: none;\n      }\n      #fileListContent.expanded li {\n        display: list-item !important;\n        white-space: normal !important;\n        opacity: 1 !important;\n      }\n      #fileListContent.expanded li:nth-child(6)::after {\n        display: none;\n      }\n      #toggleBtn {\n        color: #3498db;\n        cursor: pointer;\n        border: none;\n        background: none;\n        padding: 5px 10px;\n        width: 100%;\n        text-align: center;\n        margin-top: 10px;\n        font-size: 16px;\n      }\n      .file-list-ul {\n        list-style-type: disc !important;\n        padding-left: 20px;\n        margin: 0;\n      }\n      .file-list-ul li {\n        list-style-type: disc !important;\n      }\n    \")),\n    tags$script(HTML(\"\n      function toggleFileList() {\n        var content = document.getElementById('fileListContent');\n        var btn = document.getElementById('toggleBtn');\n        if (content.classList.contains('expanded')) {\n          content.classList.remove('expanded');\n          btn.innerHTML = '▾';\n        } else {\n          content.classList.add('expanded');\n          btn.innerHTML = '▴';\n        }\n      }\n    \"))\n  ),\n  sidebarLayout(\n    sidebarPanel(\n      # Static text inputs for certain columns\n      textInput(\"product_id\", \"Product ID\", \"\"),\n      textInput(\"product_name\", \"Product Name\", \"\"),\n      textInput(\"keywords\", \"Keywords\", \"\", placeholder = \"variant, genbank, lineage\"),\n\n\n      \n      # Static text inputs dynamically pulled from metadata.csv for certain columns\n      selectInput(\"location\", \"Location\", choices = c(\"All\", unique(split_values(metadata$Location, unlist=T))), selected = \"All\"),\n      selectInput(\"steward\", \"Steward\", choices = c(\"All\", unique(split_values(metadata$Steward, unlist=T))), selected = \"All\"),\n      selectInput(\"users\", \"Users\", choices = c(\"All\", unique(split_values(metadata$Users, unlist=T))), selected = \"All\"),\n      selectInput(\"pii\", \"PII\", choices = c(\"All\", unique(split_values(metadata$PII, unlist=T))), selected = \"All\"),\n      selectInput(\"source\", \"Source\", choices = c(\"All\", unique(split_values(metadata$Source, unlist=T))), selected = \"All\"),\n      selectInput(\"ftype\", \"File Type\", choices = c(\"All\", unique(tolower(gsub(\"^.+\\\\.(.+)$\", \"\\\\1\", metadata$Connection)))), selected = \"All\")\n    ),\n    mainPanel(\n      h3(\"Filters Applied:\"),\n      uiOutput(\"filtersSummary\"),\n      br(),\n      h3(\"Filtered File Paths:\"),\n      uiOutput(\"fileList\"),\n      br(),\n      h3(\"Selected File Data:\"),\n      DTOutput(\"fileDataTable\"),\n      uiOutput(\"docx_content\"),\n      br()\n    )\n  )\n)\n\n# Define the server logic\nmetadata_server &lt;- function(input, output, session) {\n  observe({\n    output$fileList &lt;- renderUI({\n      file_paths &lt;- filteredData()$Connection\n      \n      tagList(\n        tags$div(\n          id = \"fileListContent\",\n          tags$ul(\n            class = \"file-list-ul\",\n            lapply(seq_along(file_paths), function(i) {\n              tags$li(\n                actionLink(\n                  inputId = paste0(\"file_\", i),\n                  label = file_paths[i],\n                  onclick = sprintf(\"Shiny.setInputValue('last_clicked', '%s', {priority: 'event'});\", \n                                    paste0(\"file_\", i))\n                )\n              )\n            })\n          )\n        ),\n        tags$button(\n          id = \"toggleBtn\",\n          onclick = \"toggleFileList()\",\n          \"▾\"\n        )\n      )\n    })\n  }, priority = 1000)\n  \n  # Original filtering logic remains the same\n  filteredData &lt;- reactive({\n    data &lt;- metadata\n    \n    # Apply filters based on input values\n    if (!is.null(input$product_id) && input$product_id != \"\") {\n      data &lt;- subset(data, grepl(input$product_id, Product_ID, ignore.case = TRUE))\n    }\n    if (!is.null(input$product_name) && input$product_name != \"\") {\n      data &lt;- subset(data, grepl(input$product_name, Product_Name, ignore.case = TRUE))\n    }\n    if (input$keywords != \"\") {\n      data &lt;- subset(data, grepl(input$keywords, Keywords, ignore.case = TRUE))\n    }\n    if (!is.null(input$location) && input$location != \"All\") {\n      data &lt;- subset(data, sapply(split_values(Location), function(.) input$location %in% .))\n    }\n    if (!is.null(input$steward) && input$steward != \"All\") {\n      data &lt;- subset(data, sapply(split_values(Steward), function(.) input$steward %in% .))\n    }\n    if (!is.null(input$users) && input$users != \"All\") {\n      data &lt;- subset(data, sapply(split_values(Users), function(.) input$users %in% .))\n    }\n    if (!is.null(input$pii) && input$pii != \"All\") {\n      data &lt;- subset(data, sapply(split_values(PII), function(.) input$pii %in% .))\n    }\n    if (!is.null(input$source) && input$source != \"All\") {\n      data &lt;- subset(data, sapply(split_values(Source), function(.) input$source %in% .))\n    }\n    if (!is.null(input$ftype) && input$ftype != \"All\") {\n      data &lt;- subset(data, grepl(paste0(\"\\\\.\", input$ftype), Connection, ignore.case=TRUE))\n    }\n    \n    return(data)\n  })\n  # Modified filters summary with enhanced styling\n  output$filtersSummary &lt;- renderUI({\n    filters &lt;- list()\n    \n    if (!is.null(input$product_id) && input$product_id != \"\") {\n      filters$product_id &lt;- list(label = \"Product ID\", value = input$product_id)\n    }\n    if (!is.null(input$product_name) && input$product_name != \"\") {\n      filters$product_name &lt;- list(label = \"Product Name\", value = input$product_name)\n    }\n    if (!is.null(input$keywords) && input$keywords != \"\") {\n      filters$keywords &lt;- list(label = \"Keywords\", value = input$keywords)\n    }\n    if (!is.null(input$location) && input$location != \"All\") {\n      filters$location &lt;- list(label = \"Location\", value = input$location)\n    }\n    if (!is.null(input$steward) && input$steward != \"All\") {\n      filters$steward &lt;- list(label = \"Steward\", value = input$steward)\n    }\n    if (!is.null(input$users) && input$users != \"All\") {\n      filters$users &lt;- list(label = \"Users\", value = input$users)\n    }\n    if (!is.null(input$pii) && input$pii != \"All\") {\n      filters$pii &lt;- list(label = \"PII\", value = input$pii)\n    }\n    if (!is.null(input$source) && input$source != \"All\") {\n      filters$source &lt;- list(label = \"Source\", value = input$source)\n    }\n    if (!is.null(input$ftype) && input$ftype != \"All\") {\n      filters$ftype &lt;- list(label = \"File Type\", value = input$ftype)\n    }\n    \n    if (length(filters) == 0) {\n      return(p(\"No filters applied.\"))\n    } else {\n      # Create interactive filter tags with enhanced styling\n      tags$div(\n        lapply(names(filters), function(filter_name) {\n          tags$div(\n            class = \"filter-tag\",\n            onclick = sprintf(\"Shiny.setInputValue('remove_filter', '%s', {priority: 'event'});\", filter_name),\n            tags$span(\n              class = \"filter-label\",\n              filters[[filter_name]]$label\n            ),\n            tags$span(\n              class = \"filter-value\",\n              filters[[filter_name]]$value\n            ),\n            tags$span(\n              class = \"remove-icon\",\n              HTML(\"&times;\")\n            )\n          )\n        })\n      )\n    }\n  })\n  \n  # Observer to handle filter removal\n  observeEvent(input$remove_filter, {\n    filter_name &lt;- input$remove_filter\n    if (filter_name %in% c(\"product_id\", \"product_name\", \"keywords\")) {\n      updateTextInput(session, filter_name, value = \"\")\n    } else {\n      updateSelectInput(session, filter_name, selected = \"All\")\n    }\n  })\n  \n  # Reactive value to store the selected file path\n  selectedFile &lt;- reactiveVal(NULL)\n  \n  # Replace the original observer with this new one that responds to last_clicked\n  observeEvent(input$last_clicked, {\n    file_index &lt;- as.numeric(gsub(\"file_\", \"\", input$last_clicked))\n    file_paths &lt;- filteredData()$Connection\n    if (file_index &lt;= length(file_paths)) {\n      selectedFile(file_paths[file_index])\n    }\n  }, ignoreInit = TRUE)\n  \n  # Render the data from the selected file\n  output$fileDataTable &lt;- renderDT({\n    req(selectedFile())  # Ensure there is a selected file\n    if (grepl('\\\\.csv$', selectedFile())) {\n      tryCatch({\n        file_url &lt;- paste0('https://raw.githubusercontent.com/NW-PaGe/dstt_catalog_demo/refs/heads/main/', selectedFile())\n        file_data &lt;- read.csv(url(file_url))\n        # Convert dataframe to datatable object\n        datatable(file_data, options = list(pageLength = 10, autoWidth = TRUE))\n      }, error = function(e) {\n        datatable(data.frame(Error = paste(\"Unable to read file:\", e$message)),\n                  options = list(pageLength = 1, dom = 't'))\n      })\n    } else if (grepl('\\\\.parquet$', selectedFile())) {\n      tryCatch({\n        # get file location url\n        file_url &lt;- paste0('https://raw.githubusercontent.com/NW-PaGe/dstt_catalog_demo/refs/heads/main/', selectedFile())\n        # check file size before downloading:\n        api_url &lt;- paste0(\"https://api.github.com/repos/NW-PaGe/dstt_catalog_demo/contents/\", selectedFile()) # Construct the GitHub API URL for the file\n        con &lt;- url(api_url, \"rb\") # open connection\n        response &lt;- readLines(con) # get response\n        close(con) # close connection\n        json_data &lt;- jsonlite::fromJSON(paste(response, collapse = '')) # parse json response\n        file_size &lt;- as.numeric(json_data$size)/1024  # get size in KB\n        # download parquet if small enough file\n        if (file_size &lt; 100000) { # check if file is under 100 KB before attempting download\n          # Need to download temp file since httpfs extension not usable with Shinylive:\n          temp_file &lt;- tempfile(fileext = \".parquet\") # create temp parquet file\n          download.file(file_url, temp_file, mode = \"wb\")  # write data from file at url to temp file\n          # read parquet\n          con &lt;- dbConnect(duckdb(), ':memory:') # create db in mem\n          file_data &lt;- dbGetQuery(con, glue::glue(\"SELECT * FROM read_parquet('{temp_file}') LIMIT 10000\")) # Read data and limit preview size to 10k rows\n          dbDisconnect(con, shutdown = TRUE) # close in mem db connection\n          # convert dataframe to datatable object\n          datatable(file_data, options = list(pageLength = 10, autoWidth = TRUE))\n        } else {\n          datatable(data.frame(Warning = paste(\"Unable to read file: File too large. File size (KB):\", format(file_size, nsmall=2, big.mark=','))),\n                    options = list(pageLength = 1, dom = 't'))\n        }\n      }, error = function(e) {\n        datatable(data.frame(Error = paste(\"Unable to read file:\", e$message)),\n                  options = list(pageLength = 1, dom = 't'))\n      })\n    } else {\n      datatable(data.frame())\n    }\n  })\n  \n  # Render docx content\n  output$docx_content &lt;- renderUI({\n    req(selectedFile())  # Ensure there is a selected file\n    if (grepl('\\\\.docx$', selectedFile())) {\n      tryCatch({\n        file_url &lt;- paste0('https://raw.githubusercontent.com/NW-PaGe/dstt_catalog_demo/main/', selectedFile())\n        temp_file &lt;- tempfile(fileext = \".docx\")\n        download.file(file_url, destfile = temp_file, mode = \"wb\")\n        # Read the .docx file using officer\n        doc &lt;- read_docx(temp_file)\n        # Convert docx to html element using code from src\n        docx_to_html(doc)\n      }, error = function(e) {\n        HTML(paste(\"Unable to read file:\", e$message))\n      })\n    } else {\n      HTML('')\n    }\n  })\n}\n\n# # Run the application \n# shinyApp(ui=metadata_ui, server=metadata_server)\n\n\n# Create main ui\nui &lt;- fluidPage(\n  tags$style(\n    HTML(\"\n          h1.title {\n            text-align: center;\n            font-weight: bold;\n          }\n          hr.div {\n            width: 100%;\n            border: 5px dotted #000000;\n            border-style: none none dotted;\n          }\n         \")\n  ),\n  tags$br(id='dag-br'),\n  h1(id='dag', class='title', 'Directed Acyclic Graph (DAG):'),\n  tags$br(),\n  tags$br(),\n  fluidRow(column(12, dag_ui)), # insert dag ui\n  tags$hr(class='div'),\n  tags$br(id='metadata-viewer-br'),\n  h1(id='metadata-viewer', class='title', 'Metadata Viewer:'),\n  tags$br(),\n  tags$br(),\n  fluidRow(column(12, metadata_ui)) # insert metadata ui \n)\n\n# create main app\nserver &lt;- function(input, output, session) {\n  dag_server(input, output, session) # insert dag server logic\n  metadata_server(input, output, session) # insert metadata server logic\n}\n\nshinyApp(ui, server)"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Philip Crain\nFrank Aragona\nCory Yun\nKristen Waterman\nKathleen Conery\n\nIn the subject line, please include “DSTT Catalog Demo” for any questions regarding this repository, it’s processes or data produced.\n\n\n\n\nGenomic sequencing and related Advanced Molecular Detection (AMD) work at the Washington State Department of Health (WADOH) requires extensive interdisciplinary collaboration\nAMD data are generated, transformed, analyzed, and shared by many different teams including:\n\nBioinformatics: this team generates assembly data from raw reads generated by the Washington State Public Health Laboratory (PHL), validates new pipelines, and submits assembly data to public repositories (such as those hosted by NCBI: GenBank, RefSeq, and others).\nData Integration and Quality Assurance: this team extracts and transforms sequencing metadata submitted by sequencing laboratories and links these data to case data within the state public health surveillance system.\nMolecular Epi: this team analyzes transformed assembly data from multiple different sources and generates reports for internal and external stakeholders.\n\nData are stored in siloed environments that have limited access, limited/no information on how to request access, and lack of visibility that the data is even being generated and owned by other teams at WADOH.\nThere is a need for greater visibility around AMD data at WADOH. Data need to be discoverable and explorable. Downstream users need to understand the lineage of the data they are using.\n\n\n\n\nWe assembled members of a Data Science Training Team with representation from three distinct AMD teams at WADOH (described above). This team set out to build a model data catalog to demonstrate a solution addressing the needs for greater visibility around data and data lineage.\nThe goals of the data catalog were to: - Explore metadata fields required for a minimum viable product (MVP) - Visualize data lineage through a Directed Acyclic Graph (DAG) - Build an example infrastructure that could be used to make AMD data explorable and discoverable at WADOH\n\n\n\n\nBuilt in Shinylive R, a serverless Shiny package which can render and run code in a browser. WebAssembly in package is used to make page serverless.\nPackaged into a Quarto website. This allows for easy web design, theming, and page organization. Quarto supports running R code blocks (along with other languages) and has built-in Observable JS support.\nDeployed by GitHub Actions and published on GitHub Pages: GitHub Actions render and deployment allows for automatic updating of GitHub Pages with prod GitHub repository releases. GitHub Pages allows for web hosting a serverless website.\n\n\n\n\nThis work was executed as part of the CSTE Data Science Training Team program. The primary goal of this work was to increase data science skills and knowledge. This Data Catalog is not intended to be used as a final or scalable product."
  },
  {
    "objectID": "about.html#authors",
    "href": "about.html#authors",
    "title": "About",
    "section": "",
    "text": "Philip Crain\nFrank Aragona\nCory Yun\nKristen Waterman\nKathleen Conery\n\nIn the subject line, please include “DSTT Catalog Demo” for any questions regarding this repository, it’s processes or data produced."
  },
  {
    "objectID": "about.html#business-need",
    "href": "about.html#business-need",
    "title": "About",
    "section": "",
    "text": "Genomic sequencing and related Advanced Molecular Detection (AMD) work at the Washington State Department of Health (WADOH) requires extensive interdisciplinary collaboration\nAMD data are generated, transformed, analyzed, and shared by many different teams including:\n\nBioinformatics: this team generates assembly data from raw reads generated by the Washington State Public Health Laboratory (PHL), validates new pipelines, and submits assembly data to public repositories (such as those hosted by NCBI: GenBank, RefSeq, and others).\nData Integration and Quality Assurance: this team extracts and transforms sequencing metadata submitted by sequencing laboratories and links these data to case data within the state public health surveillance system.\nMolecular Epi: this team analyzes transformed assembly data from multiple different sources and generates reports for internal and external stakeholders.\n\nData are stored in siloed environments that have limited access, limited/no information on how to request access, and lack of visibility that the data is even being generated and owned by other teams at WADOH.\nThere is a need for greater visibility around AMD data at WADOH. Data need to be discoverable and explorable. Downstream users need to understand the lineage of the data they are using."
  },
  {
    "objectID": "about.html#project-goals",
    "href": "about.html#project-goals",
    "title": "About",
    "section": "",
    "text": "We assembled members of a Data Science Training Team with representation from three distinct AMD teams at WADOH (described above). This team set out to build a model data catalog to demonstrate a solution addressing the needs for greater visibility around data and data lineage.\nThe goals of the data catalog were to: - Explore metadata fields required for a minimum viable product (MVP) - Visualize data lineage through a Directed Acyclic Graph (DAG) - Build an example infrastructure that could be used to make AMD data explorable and discoverable at WADOH"
  },
  {
    "objectID": "about.html#infrastructure",
    "href": "about.html#infrastructure",
    "title": "About",
    "section": "",
    "text": "Built in Shinylive R, a serverless Shiny package which can render and run code in a browser. WebAssembly in package is used to make page serverless.\nPackaged into a Quarto website. This allows for easy web design, theming, and page organization. Quarto supports running R code blocks (along with other languages) and has built-in Observable JS support.\nDeployed by GitHub Actions and published on GitHub Pages: GitHub Actions render and deployment allows for automatic updating of GitHub Pages with prod GitHub repository releases. GitHub Pages allows for web hosting a serverless website."
  },
  {
    "objectID": "about.html#disclaimer",
    "href": "about.html#disclaimer",
    "title": "About",
    "section": "",
    "text": "This work was executed as part of the CSTE Data Science Training Team program. The primary goal of this work was to increase data science skills and knowledge. This Data Catalog is not intended to be used as a final or scalable product."
  }
]